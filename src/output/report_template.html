<!DOCTYPE html>
<!--suppress TypeScriptMissingConfigOption -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Blame Statistics</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.plot.ly/plotly-3.3.0.min.js" charset="utf-8"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <!-- React 18 UMD builds -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel Standalone for in-browser JSX transform -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="font-sans m-0 bg-gray-50 text-gray-900">
<div id="root"></div>
<script type="text/babel" data-presets="react">
    const RAW_DATASET =
        __DATASET_JSON__
        || [];
    // Fixed schema as per pipeline: [author, days_bucket, lang, clusterPath, repoName, count]
    const HEADER_LABELS = ["author", "days_bucket", "lang", "clusterPath", "repoName", "count"];
    // -------- Client-side grouping/filtering engine --------
    const KEY_INDEX = Object.fromEntries(HEADER_LABELS.map((k, i) => [k, i]));
    const COUNT_IDX_FROM_END = 1; // last element is count

    const allKeys = HEADER_LABELS.filter(k => k !== 'count');
    const TOP_N = 20;
    const BUCKET_COLORS = [
        'rgba(214, 40, 40, 0.7)',
        'rgba(247, 127, 0, 0.7)',
        'rgba(252, 191, 73, 0.7)',
        'rgba(168, 218, 142, 0.7)',
        'rgba(75, 192, 192, 0.7)',
        'rgba(54, 162, 235, 0.7)',
        'rgba(153, 102, 255, 0.7)',
        'rgba(201, 203, 207, 0.7)'
    ];

    function uniqueValues(arr, idx) {
        const set = new Set(arr.map(r => r[idx]));
        return Array.from(set);
    }

    function pivot(
        dataset,
        primaryKeyIndex,
        secondaryKeyIndex,
        filterState
    ) {
        const pivot = new Map();
        const totals = new Map();
        const secValuesSet = new Set();
        for (const row of dataset) {
            let ok = true;
            for (const key of allKeys) {
                const idx = KEY_INDEX[key];
                const sel = filterState[key];
                if (sel && !sel.has(String(row[idx]))) {
                    ok = false;
                    break;
                }
            }
            if (!ok) continue;
            const pk = row[primaryKeyIndex];
            const sk = row[secondaryKeyIndex];
            const count = Number(row[row.length - COUNT_IDX_FROM_END]) || 0;
            if (!pivot.has(pk)) pivot.set(pk, new Map());
            pivot.get(pk).set(sk, (pivot.get(pk).get(sk) || 0) + count);
            totals.set(pk, (totals.get(pk) || 0) + count);
            secValuesSet.add(sk);
        }
        const primaryKeys = Array.from(pivot.keys()).sort((a, b) => (totals.get(b) || 0) - (totals.get(a) || 0));
        const secondaryKeys = Array.from(secValuesSet).sort((a, b) => String(a).localeCompare(String(b)));
        return {pivot, totals, primaryKeys, secondaryKeys};
    }

    // ---------- React Components ----------
    function ChartView({labels, datasets}) {
        const canvasRef = React.useRef(null);
        const chartRef = React.useRef(null);
        React.useEffect(() => {
            const ctx = canvasRef.current.getContext('2d');
            chartRef.current = new Chart(ctx, {
                type: 'bar',
                data: {labels: [], datasets: []},
                options: {
                    indexAxis: 'y',
                    scales: {
                        x: {stacked: true, beginAtZero: true},
                        y: {stacked: true, ticks: {autoSkip: false}}
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed.x !== null) label += context.parsed.x.toLocaleString();
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
            return () => {
                chartRef.current && chartRef.current.destroy();
            };
        }, []);

        React.useEffect(() => {
            if (!chartRef.current) return;
            chartRef.current.data.labels = labels;
            chartRef.current.data.datasets = datasets;
            chartRef.current.update();
        }, [labels, datasets]);

        return <canvas ref={canvasRef}/>;
    }

    // ---------- Sunburst over repository paths (clusterPath) ----------
    function buildSunburst(dataset, filterState) {
        // Filter rows according to current filters
        const filtered = [];
        for (const row of dataset) {
            let ok = true;
            for (const key of allKeys) {
                const idx = KEY_INDEX[key];
                const sel = filterState[key];
                if (sel && !sel.has(String(row[idx]))) {
                    ok = false;
                    break;
                }
            }
            if (ok) filtered.push(row);
        }

        // Aggregate counts per path and propagate sums up the tree
        const LEAF_IDX = KEY_INDEX['clusterPath'];
        const COUNT_IDX = HEADER_LABELS.length - COUNT_IDX_FROM_END;
        const leafSums = new Map(); // fullPath -> sum
        const allPaths = new Set(); // includes all prefixes (no empty)

        for (const row of filtered) {
            const rawPath = String(row[LEAF_IDX] ?? '').trim();
            const cnt = Number(row[COUNT_IDX]) || 0;
            if (!rawPath) continue;
            const segs = rawPath.split('/').filter(s => s && s !== '.');
            if (segs.length === 0) continue;
            const full = segs.join('/');
            leafSums.set(full, (leafSums.get(full) || 0) + cnt);
            // Collect all prefix nodes for structure
            for (let i = 0; i < segs.length; i++) {
                const p = segs.slice(0, i + 1).join('/');
                allPaths.add(p);
            }
        }

        if (allPaths.size === 0) return {ids: [], labels: [], parents: [], values: []};

        // Compute total values for every node as sum of its descendant leaves
        const totals = new Map(Array.from(allPaths, p => [p, 0]));
        for (const [leaf, v] of leafSums) {
            const segs = leaf.split('/');
            for (let i = 0; i < segs.length; i++) {
                const p = segs.slice(0, i + 1).join('/');
                totals.set(p, (totals.get(p) || 0) + v);
            }
        }

        // Build Plotly arrays
        const ids = [];
        const labels = [];
        const parents = [];
        const values = [];

        // Ensure stable ordering: sort by path length then alphabetically
        const ordered = Array.from(allPaths);
        ordered.sort((a, b) => {
            const da = a.split('/').length, db = b.split('/').length;
            if (da !== db) return da - db;
            return a.localeCompare(b);
        });

        for (const id of ordered) {
            const segs = id.split('/');
            const label = segs[segs.length - 1] || id;
            const parent = segs.length > 1 ? segs.slice(0, -1).join('/') : '';
            ids.push(id);
            labels.push(label);
            parents.push(parent);
            values.push(totals.get(id) || 0);
        }

        return {ids, labels, parents, values};
    }

    function SunburstPaths({dataset, filters}) {
        const containerRef = React.useRef(null);
        const data = React.useMemo(() => buildSunburst(dataset, filters), [dataset, filters]);

        React.useEffect(() => {
            const el = containerRef.current;
            if (!el) return;
            if (!data.ids.length) {
                el.innerHTML = '<div class="text-gray-500 py-6 text-center">No path data to display</div>';
                return;
            }
            const trace = {
                type: 'sunburst',
                ids: data.ids,
                labels: data.labels,
                parents: data.parents,
                values: data.values,
                branchvalues: 'total',
                maxdepth: 8
            };
            const layout = {
                margin: {l: 0, r: 0, t: 10, b: 10},
                sunburstcolorway: ['#4F46E5', '#10B981', '#F59E0B', '#EF4444', '#06B6D4', '#8B5CF6', '#F43F5E'],
                extendsunburstcolors: true,
                height: 400
            };
            const config = {responsive: true, displayModeBar: false};
            // Use Plotly from global
            if (window.Plotly && window.Plotly.newPlot) {
                window.Plotly.newPlot(el, [trace], layout, config);
            }
        }, [data]);

        return <div ref={containerRef} className="w-full"/>;
    }

    function MultiSelect({label, values, selectedSet, onChange}) {
        const [isOpen, setIsOpen] = React.useState(false);
        const [searchTerm, setSearchTerm] = React.useState('');
        const dropdownRef = React.useRef(null);

        React.useEffect(() => {
            function handleClickOutside(event) {
                if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
                    setIsOpen(false);
                }
            }

            document.addEventListener('mousedown', handleClickOutside);
            return () => document.removeEventListener('mousedown', handleClickOutside);
        }, []);

        const filteredValues = React.useMemo(() => {
            if (!searchTerm) return values;
            const lower = searchTerm.toLowerCase();
            return values.filter(v => String(v).toLowerCase().includes(lower));
        }, [values, searchTerm]);

        const selCount = selectedSet.size;
        const total = values.length;

        const toggleValue = (strVal) => {
            const newSet = new Set(selectedSet);
            if (newSet.has(strVal)) {
                newSet.delete(strVal);
            } else {
                newSet.add(strVal);
            }
            onChange(newSet);
        };

        return (
            <div ref={dropdownRef} className="relative">
                <label className="block font-semibold mb-1.5">
                    {label}{' '}
                    <span className="text-gray-600 font-normal">({selCount}/{total})</span>
                </label>
                <button
                    type="button"
                    onClick={() => setIsOpen(!isOpen)}
                    className="w-full px-3 py-2 text-left bg-white border border-gray-300 rounded-md shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                >
                    <span className="text-gray-700">
                        {selCount === 0 ? 'Select...' : selCount === total ? 'All selected' : `${selCount} selected`}
                    </span>
                    <span className="float-right">â–¼</span>
                </button>
                {isOpen && (
                    <div
                        className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-80 overflow-hidden">
                        <div className="p-2 border-b border-gray-200">
                            <input
                                type="text"
                                placeholder="Search..."
                                value={searchTerm}
                                onChange={(e) => setSearchTerm(e.target.value)}
                                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                onClick={(e) => e.stopPropagation()}
                            />
                            <div className="flex gap-2 mt-2">
                                <button
                                    type="button"
                                    onClick={() => onChange(new Set(values.map(String)))}
                                    className="flex-1 px-3 py-1.5 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
                                >
                                    Select All
                                </button>
                                <button
                                    type="button"
                                    onClick={() => onChange(new Set())}
                                    className="flex-1 px-3 py-1.5 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500"
                                >
                                    Unselect All
                                </button>
                            </div>
                        </div>
                        <div className="overflow-y-auto max-h-64">
                            {filteredValues.length === 0 ? (
                                <div className="px-3 py-2 text-gray-500 text-center">No matches found</div>
                            ) : (
                                filteredValues.map(v => {
                                    const strVal = String(v);
                                    const isChecked = selectedSet.has(strVal);
                                    return (
                                        <label
                                            key={strVal}
                                            className="flex items-center px-3 py-2 hover:bg-gray-100 cursor-pointer"
                                        >
                                            <input
                                                type="checkbox"
                                                checked={isChecked}
                                                onChange={() => toggleValue(strVal)}
                                                className="mr-2 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                                            />
                                            <span className="text-gray-900">{strVal}</span>
                                        </label>
                                    );
                                })
                            )}
                        </div>
                    </div>
                )}
            </div>
        );
    }

    function App() {
        const {initialFilters, valueOptions} = React.useMemo(() => {
            const filters = {};
            const options = {};
            for (const key of allKeys) {
                const idx = KEY_INDEX[key];
                const values = uniqueValues(RAW_DATASET, idx).sort((a, b) => {
                    if (key === 'days_bucket') return Number(a) - Number(b);
                    return String(a).localeCompare(String(b));
                });
                filters[key] = new Set(values.map(v => String(v)));
                options[key] = values;
            }
            return {initialFilters: filters, valueOptions: options};
        }, []);
        const [filters, setFilters] = React.useState(initialFilters);
        const [primaryKeyIndex, setPrimaryKeyIndex] = React.useState(0);
        const [secondaryKeyIndex, setSecondaryKeyIndex] = React.useState(1);

        const {chartLabels, datasets} = React.useMemo(() => {
            const {
                pivot: pv,
                primaryKeys,
                secondaryKeys
            } = pivot(RAW_DATASET, primaryKeyIndex, secondaryKeyIndex, filters);
            const chartPrimaryKeys = primaryKeys.slice(0, TOP_N);
            const ds = secondaryKeys.map((sk, i) => ({
                label: String(sk),
                data: chartPrimaryKeys.map(pk => (pv.get(pk)?.get(sk)) || 0),
                backgroundColor: BUCKET_COLORS[i % BUCKET_COLORS.length]
            }));
            return {chartLabels: chartPrimaryKeys, datasets: ds};
        }, [filters, primaryKeyIndex, secondaryKeyIndex]);

        return (
            <div className="max-w-4xl mx-auto my-5 p-5 bg-white rounded-lg shadow-sm">
                <h1 className="border-b border-gray-300 pb-2.5">Git Contribution Statistics</h1>
                <div className="controls">
                    <h2 className="border-b border-gray-300 pb-2.5">Controls</h2>
                    <div className="flex gap-4 flex-wrap items-center">
                        <label>
                            Primary group:
                            <select value={primaryKeyIndex} onChange={e => setPrimaryKeyIndex(Number(e.target.value))}>
                                {allKeys.map((__, i) => (
                                    <option key={i} value={i}>{HEADER_LABELS[i]}</option>
                                ))}
                            </select>
                        </label>
                        <label>
                            Secondary group:
                            <select value={secondaryKeyIndex}
                                    onChange={e => setSecondaryKeyIndex(Number(e.target.value))}>
                                {allKeys.map((__, i) => (
                                    <option key={i} value={i}>{HEADER_LABELS[i]}</option>
                                ))}
                            </select>
                        </label>
                    </div>
                    <div id="filters" className="mt-3 grid grid-cols-[repeat(auto-fit,minmax(220px,1fr))] gap-3">
                        {allKeys.map((key, idx) => (
                            <MultiSelect
                                key={idx}
                                label={HEADER_LABELS[idx]}
                                values={valueOptions[key]}
                                selectedSet={filters[key]}
                                onChange={(newSet) => setFilters(prev => ({...prev, [key]: newSet}))}
                            />
                        ))}
                    </div>
                </div>
                <div className="mt-5">
                    <h2 id="chartTitle" className="border-b border-gray-300 pb-2.5">Chart</h2>
                    <ChartView labels={chartLabels} datasets={datasets}/>
                </div>
                <div className="mt-8">
                    <h2 className="border-b border-gray-300 pb-2.5">Repository Paths Sunburst</h2>
                    <p className="text-sm text-gray-600 mt-2 mb-3">Breakdown by folder structure based on <code>clusterPath</code> within current filters.</p>
                    <SunburstPaths dataset={RAW_DATASET} filters={filters}/>
                </div>
            </div>
        );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App/>);
</script>
</body>
</html>
