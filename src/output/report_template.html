<!DOCTYPE html>
<!--suppress TypeScriptMissingConfigOption -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Blame Statistics</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.plot.ly/plotly-3.3.0.min.js" charset="utf-8"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <!-- Preact UMD build -->
    <script crossorigin src="https://unpkg.com/preact@10/dist/preact.umd.js"></script>
    <script crossorigin src="https://unpkg.com/preact@10/hooks/dist/hooks.umd.js"></script>
    <!-- Babel Standalone for in-browser JSX transform -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="font-sans m-0 bg-gray-50 text-gray-900">
<div id="root"></div>
</body>
<script type="text/babel" data-presets="react">
    // Preact compat aliases
    const React = window.preact;
    const ReactDOM = {
        createRoot: (container) => ({
            render: (element) => window.preact.render(element, container)
        })
    };
    React.useRef = window.preactHooks.useRef;
    React.useEffect = window.preactHooks.useEffect;
    React.useState = window.preactHooks.useState;
    React.useMemo = window.preactHooks.useMemo;

    const RAW_DATASET =
        __DATASET_JSON__
        || [];
    // Fixed schema as per pipeline: [author, days_bucket, lang, clusterPath, repoName, count]
    const RAW_DATASET_SCHEMA = ["author", "days_bucket", "lang", "clusterPath", "repoName", "count"];
    // -------- Client-side grouping/filtering engine --------
    const KEY_INDEX = Object.fromEntries(RAW_DATASET_SCHEMA.map((k, i) => [k, i]));
    const COLUMNS_AMOUNT = RAW_DATASET_SCHEMA.length - 1;
    const COLUMNS_IDX_ARRAY = Array(COLUMNS_AMOUNT).fill(-1).map((_, i) => i);
    const COUNT_IDX_FROM_END = 1; // last element is count
    const COLUMN_COMPARATORS = COLUMNS_IDX_ARRAY.map(idx => {
        let isNumber = typeof RAW_DATASET?.[0]?.[idx] === "number";
        return isNumber ? ((a, b) => (a || 0) - (b || 0)) : (a, b) => String(a).localeCompare(String(b));
    })
    const UNIQUE_VALUES = COLUMNS_IDX_ARRAY.map((idx) => uniqueValues(RAW_DATASET, idx).sort(COLUMN_COMPARATORS[idx]))

    console.log("UN", COLUMNS_IDX_ARRAY)

    function property(initialValue) {
        let value = initialValue;
        const listeners = new Set();

        return Object.freeze({
            get() {
                return value;
            },

            set(newValue) {
                if (Object.is(value, newValue)) return;
                value = newValue;
                listeners.forEach(fn => fn(value));
            },

            listen(fn) {
                listeners.add(fn);
                // optional: return unsubscribe function
                return () => listeners.delete(fn);
            }
        });
    }

    const TOP_N = 20;
    const BUCKET_COLORS = [
        'rgba(214, 40, 40, 0.7)',
        'rgba(247, 127, 0, 0.7)',
        'rgba(252, 191, 73, 0.7)',
        'rgba(168, 218, 142, 0.7)',
        'rgba(75, 192, 192, 0.7)',
        'rgba(54, 162, 235, 0.7)',
        'rgba(153, 102, 255, 0.7)',
        'rgba(201, 203, 207, 0.7)'
    ];

    function uniqueValues(arr, idx) {
        const set = new Set(arr.map(r => r[idx]));
        return Array.from(set);
    }

    function pivot(
        dataset,
        column1,
        column2
    ) {
        const grouped2 = new Map();
        const grouped1 = new Map();
        const secValuesSet = new Set();
        for (const row of filteredDataset) {
            const c1 = row[column1];
            const c2 = row[column2];
            const count = Number(row[row.length - COUNT_IDX_FROM_END]) || 0;
            if (!grouped2.has(c1)) grouped2.set(c1, new Map());
            grouped2.get(c1).set(c2, (grouped2.get(c1).get(c2) || 0) + count);

            grouped1.set(c1, (grouped1.get(c1) || 0) + count);

            secValuesSet.add(c2);
        }
        const primaryKeys = Array.from(grouped2.keys()).sort((a, b) => (grouped1.get(b) || 0) - (grouped1.get(a) || 0));
        const secondaryKeys = Array.from(secValuesSet).sort((a, b) => String(a).localeCompare(String(b)));
        return {grouped2, grouped1, primaryKeys, secondaryKeys};
    }

    // ---------- React Components ----------
    function ChartView({labels, datasets}) {
        const canvasRef = React.useRef(null);
        const chartRef = React.useRef(null);
        React.useEffect(() => {
            const ctx = canvasRef.current.getContext('2d');
            chartRef.current = new Chart(ctx, {
                type: 'bar',
                data: {labels: [], datasets: []},
                options: {
                    indexAxis: 'y',
                    scales: {
                        x: {stacked: true, beginAtZero: true},
                        y: {stacked: true, ticks: {autoSkip: false}}
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed.x !== null) label += context.parsed.x.toLocaleString();
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
            return () => {
                chartRef.current && chartRef.current.destroy();
            };
        }, []);

        React.useEffect(() => {
            if (!chartRef.current) return;
            chartRef.current.data.labels = labels;
            chartRef.current.data.datasets = datasets;
            chartRef.current.update();
        }, [labels, datasets]);

        return <canvas ref={canvasRef}/>;
    }

    // ---------- Sunburst over repository paths (clusterPath) ----------
    function buildSunburst(dataset, filterState) {
        // Filter rows according to current filters
        const filtered = [];
        for (const row of dataset) {
            let ok = true;
            for (let idx = 0; idx < COLUMNS_AMOUNT; idx++) {
                const sel = filterState[idx + ""];
                if (sel && !sel.has(String(row[idx]))) {
                    ok = false;
                    break;
                }
            }
            if (ok) filtered.push(row);
        }

        const PSEUDO_ROOT = "@";
        // Aggregate counts per path and propagate sums up the tree
        const LEAF_IDX = KEY_INDEX['clusterPath'];
        const COUNT_IDX = RAW_DATASET_SCHEMA.length - COUNT_IDX_FROM_END;
        const leafSums = new Map(); // fullPath -> sum
        const allPaths = new Set(); // includes all prefixes (no empty)

        for (const row of filtered) {
            const rawPath = String(PSEUDO_ROOT + "/" + row[LEAF_IDX] ?? '').trim();
            const cnt = Number(row[COUNT_IDX]) || 0;
            if (!rawPath) continue;
            const segs = rawPath.split('/').filter(s => s && s !== '.');
            if (segs.length === 0) continue;
            const full = segs.join('/');
            leafSums.set(full, (leafSums.get(full) || 0) + cnt);
            // Collect all prefix nodes for structure
            for (let i = 0; i < segs.length; i++) {
                const p = segs.slice(0, i + 1).join('/');
                allPaths.add(p);
            }
        }

        if (allPaths.size === 0) return {ids: [], labels: [], parents: [], values: []};

        // Compute total values for every node as sum of its descendant leaves
        const totals = new Map(Array.from(allPaths, p => [p, 0]));
        for (const [leaf, v] of leafSums) {
            const segs = leaf.split('/');
            for (let i = 0; i < segs.length; i++) {
                const p = segs.slice(0, i + 1).join('/');
                totals.set(p, (totals.get(p) || 0) + v);
            }
        }

        // Build Plotly arrays
        const ids = [];
        const labels = [];
        const parents = [];
        const values = [];

        // Ensure stable ordering: sort by path length then alphabetically
        const ordered = Array.from(allPaths);
        ordered.sort((a, b) => {
            const da = a.split('/').length, db = b.split('/').length;
            if (da !== db) return da - db;
            return a.localeCompare(b);
        });

        for (const id of ordered) {
            const segs = id.split('/');
            const label = segs[segs.length - 1] || id;
            const parent = segs.length > 1 ? segs.slice(0, -1).join('/') : '';
            ids.push(id);
            labels.push(label);
            parents.push(parent);
            values.push(totals.get(id) || 0);
        }

        return {ids, labels, parents, values};
    }

    function SunburstPaths({dataset, filters}) {
        const containerRef = React.useRef(null);
        const data = React.useMemo(() => buildSunburst(dataset, filters), [dataset, filters]);

        React.useEffect(() => {
            const el = containerRef.current;
            if (!el) return;
            if (!data.ids.length) {
                el.innerHTML = '<div class="text-gray-500 py-6 text-center">No path data to display</div>';
                return;
            }
            const trace = {
                type: 'sunburst',
                ids: data.ids,
                labels: data.labels,
                parents: data.parents,
                values: data.values,
                branchvalues: 'total',
                maxdepth: 2
            };
            const layout = {
                margin: {l: 0, r: 0, t: 10, b: 10},
                sunburstcolorway: ['#4F46E5', '#10B981', '#F59E0B', '#EF4444', '#06B6D4', '#8B5CF6', '#F43F5E'],
                extendsunburstcolors: true,
                height: 400
            };
            const config = {responsive: true, displayModeBar: false};
            // Use Plotly from global
            if (window.Plotly && window.Plotly.newPlot) {
                window.Plotly.newPlot(el, [trace], layout, config);
            }
        }, [data]);

        return <div ref={containerRef} className="w-full"/>;
    }

    function MultiSelect({label, values, selectedSet, onChange}) {
        const [isOpen, setIsOpen] = React.useState(false);
        const [searchTerm, setSearchTerm] = React.useState('');
        const dropdownRef = React.useRef(null);

        React.useEffect(() => {
            function handleClickOutside(event) {
                if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
                    setIsOpen(false);
                }
            }

            document.addEventListener('mousedown', handleClickOutside);
            return () => document.removeEventListener('mousedown', handleClickOutside);
        }, []);

        const filteredValues = React.useMemo(() => {
            if (!searchTerm) return values;
            const lower = searchTerm.toLowerCase();
            return values.filter(v => String(v).toLowerCase().includes(lower));
        }, [values, searchTerm]);

        const selCount = selectedSet.size;
        const total = values.length;

        const toggleValue = (strVal) => {
            const newSet = new Set(selectedSet);
            if (newSet.has(strVal)) {
                newSet.delete(strVal);
            } else {
                newSet.add(strVal);
            }
            onChange(newSet);
        };

        return (
            <div ref={dropdownRef} className="relative">
                <label className="block font-semibold mb-1.5">
                    {label}{' '}
                    <span className="text-gray-600 font-normal">({selCount}/{total})</span>
                </label>
                <button
                    type="button"
                    onClick={() => setIsOpen(!isOpen)}
                    className="w-full px-3 py-2 text-left bg-white border border-gray-300 rounded-md shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                >
                    <span className="text-gray-700">
                        {selCount === 0 ? 'Select...' : selCount === total ? 'All selected' : `${selCount} selected`}
                    </span>
                    <span className="float-right">â–¼</span>
                </button>
                {isOpen && (
                    <div
                        className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-80 overflow-hidden">
                        <div className="p-2 border-b border-gray-200">
                            <input
                                type="text"
                                placeholder="Search..."
                                value={searchTerm}
                                onChange={(e) => setSearchTerm(e.target.value)}
                                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                onClick={(e) => e.stopPropagation()}
                            />
                            <div className="flex gap-2 mt-2">
                                <button
                                    type="button"
                                    onClick={() => onChange(new Set(values.map(String)))}
                                    className="flex-1 px-3 py-1.5 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
                                >
                                    Select All
                                </button>
                                <button
                                    type="button"
                                    onClick={() => onChange(new Set())}
                                    className="flex-1 px-3 py-1.5 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500"
                                >
                                    Unselect All
                                </button>
                            </div>
                        </div>
                        <div className="overflow-y-auto max-h-64">
                            {filteredValues.length === 0 ? (
                                <div className="px-3 py-2 text-gray-500 text-center">No matches found</div>
                            ) : (
                                filteredValues.map(v => {
                                    const strVal = String(v);
                                    const isChecked = selectedSet.has(strVal);
                                    return (
                                        <label
                                            key={strVal}
                                            className="flex items-center px-3 py-2 hover:bg-gray-100 cursor-pointer"
                                        >
                                            <input
                                                type="checkbox"
                                                checked={isChecked}
                                                onChange={() => toggleValue(strVal)}
                                                className="mr-2 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                                            />
                                            <span className="text-gray-900">{strVal}</span>
                                        </label>
                                    );
                                })
                            )}
                        </div>
                    </div>
                )}
            </div>
        );
    }

    function App() {
        const {initialFilters, valueOptions} = React.useMemo(() => {
            const filters = {};
            const options = {};
            for (let idx = 0; idx < COLUMNS_AMOUNT; idx++) {
                filters[idx + ""] = new Set(UNIQUE_VALUES[idx].map(v => String(v)));
                options[idx + ""] = UNIQUE_VALUES[idx];
            }
            return {initialFilters: filters, valueOptions: options};
        }, []);
        const [filters, setFilters] = React.useState(initialFilters);
        const [primaryKeyIndex, setPrimaryKeyIndex] = React.useState(0);
        const [secondaryKeyIndex, setSecondaryKeyIndex] = React.useState(1);

        const {chartLabels, datasets} = React.useMemo(() => {
            let filteredDataset = RAW_DATASET.filter(row => {
                for (let idx = 0; idx < COLUMNS_AMOUNT; idx++) {
                    const sel = filterState[idx + ""];
                    if (sel && !sel.has(String(row[idx]))) {
                        return false;
                    }
                }
                return true;
            });
            const {
                grouped2: pv,
                primaryKeys,
                secondaryKeys
            } = pivot(filteredDataset, primaryKeyIndex, secondaryKeyIndex);
            const chartPrimaryKeys = primaryKeys.slice(0, TOP_N);
            const ds = secondaryKeys.map((sk, i) => ({
                label: String(sk),
                data: chartPrimaryKeys.map(pk => (pv.get(pk)?.get(sk)) || 0),
                backgroundColor: BUCKET_COLORS[i % BUCKET_COLORS.length]
            }));
            return {chartLabels: chartPrimaryKeys, datasets: ds};
        }, [filters, primaryKeyIndex, secondaryKeyIndex]);

        return (
            <div className="max-w-4xl mx-auto my-5 p-5 bg-white rounded-lg shadow-sm">
                <h1 className="border-b border-gray-300 pb-2.5">Git Contribution Statistics</h1>
                <div className="controls">
                    <h2 className="border-b border-gray-300 pb-2.5">Controls</h2>
                    <div className="flex gap-4 flex-wrap items-center">
                        <label>
                            Primary group:
                            <select value={primaryKeyIndex} onChange={e => setPrimaryKeyIndex(Number(e.target.value))}>
                                {COLUMNS_IDX_ARRAY.map((__, i) => (
                                    <option key={i} value={i}>{RAW_DATASET_SCHEMA[i]}</option>
                                ))}
                            </select>
                        </label>
                        <label>
                            Secondary group:
                            <select value={secondaryKeyIndex}
                                    onChange={e => setSecondaryKeyIndex(Number(e.target.value))}>
                                {COLUMNS_IDX_ARRAY.map((__, i) => (
                                    <option key={i} value={i}>{RAW_DATASET_SCHEMA[i]}</option>
                                ))}
                            </select>
                        </label>
                    </div>
                    <div id="filters" className="mt-3 grid grid-cols-[repeat(auto-fit,minmax(220px,1fr))] gap-3">
                        {COLUMNS_IDX_ARRAY.map((__, idx) => (
                            <MultiSelect
                                key={idx}
                                label={RAW_DATASET_SCHEMA[idx]}
                                values={valueOptions[idx + ""]}
                                selectedSet={filters[idx + ""]}
                                onChange={(newSet) => setFilters(prev => ({...prev, [idx + ""]: newSet}))}
                            />
                        ))}
                    </div>
                </div>
                <div className="mt-5">
                    <h2 id="chartTitle" className="border-b border-gray-300 pb-2.5">Chart</h2>
                    <ChartView labels={chartLabels} datasets={datasets}/>
                </div>
                <div className="mt-8">
                    <h2 className="border-b border-gray-300 pb-2.5">Repository Paths Sunburst</h2>
                    <p className="text-sm text-gray-600 mt-2 mb-3">Breakdown by folder structure based on <code>clusterPath</code> within current filters.</p>
                    <SunburstPaths dataset={RAW_DATASET} filters={filters}/>
                </div>
            </div>
        );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App/>);
</script>
</html>
